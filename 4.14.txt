//----------------------------------------------------------------------------------------------------
					CCS2.2转CCS3.3注意事项
//----------------------------------------------------------------------------------------------------
首先CCS会自动转换，然后编译后会报很多错误。
其中最主要的错误在于少了CSL库的支持。所以在需要在xx.cmd文件里面添加需要的库
-l TScfg.cmd	---原来有的
-l csl6416.lib	---需要添加的
-l rts6400.lib	---这个貌似不需要
编译继续报错
D:/CCStudio_v3.3/C6000/csl/include/csl_chiphal.h, line 267: fatal error: #error NO CHIP DEFINED (use -dCHIP_XXXX where XXXX is chip number, i.e. 6201)
这是因为少了CHIP支持。需要在build option里面的Compiler选项卡中的prepocessor的pre-Define Symbol (-d)中 添加CHIP_6416

当然还要在一些源文件里面添加头文件#include <csl.h>和#include "TScfg_csl.h"。那些地方报错就添加在哪些地方

//----------------------------------------------------------------------------------------------------
					EMIF地址的问题(emif 16)
//----------------------------------------------------------------------------------------------------
1.EMIF可以通过BIOS来配置。但是CCS3.3不行。只能通过EMIF_CONFIG来配置。具体需要看寄存器，有已经写好的，只要拷贝就行
2.还有一个问题就是，用户操作的实际地址不能写死。比如在0x80000000写1，在0x80000001写2，在0x80000002写3...就不能直接写成
RE0=0X80000000
RE1=0X80000001
RE2=0X80000002

*(Uint16*)RE0=1;
*(Uint16*)RE1=2;
*(Uint16*)RE2=3;

上述方式是不行的


//-------------------
#define GRAY_BASE		0x80000000
#define GRAY_MEAN		((Uint16*)GRAY_BASE+(0<<1))
#define GRAY_DELTA		((Uint16*)GRAY_BASE+(1<<1))
#define GRAY_THRESHOLD		((Uint16*)GRAY_BASE+(2<<1))		//这样一下跳32位，有问题
//-------------------
上面这样是不行的，(Uint16*)只对紧跟后面的有效，要像下面用括号括起来，或者用下面的

//--------------------
#define GRAY_BASE		0x80000000
#define GRAY_MEAN		((Uint16*)GRAY_BASE+1)
#define GRAY_DELTA		((Uint16*)GRAY_BASE+2)
#define GRAY_THRESHOLD		((Uint16*)GRAY_BASE+3)			//这样一下就跳16位，没问题
//-------------------

但下面这种方式更好
//-------------------
#define GRAY_BASE		0x80000000
#define GRAY_MEAN		((Uint16*)(GRAY_BASE+(0<<1)))
#define GRAY_DELTA		((Uint16*)(GRAY_BASE+(1<<1)))
#define GRAY_THRESHOLD	((Uint16*)(GRAY_BASE+(2<<1)))		//相当于每次乘2，因为地址是32位的EMIF是16位的
//-------------------

* GRAY_MEAN = 0x64;
* GRAY_DELTA = 0x5;
* GRAY_THRESHOLD = 0x63;



//----------------------------------------------------------------------------------------------------
					控制  icache
//----------------------------------------------------------------------------------------------------
什么是 cache
基于程序访问的局限性，在主存和 CPU 通用寄存器之前设置了一类高速的、容量较小的存储
器，把正在执行的指令地址附件的一部分指令或数据从主存调入这类存储器，供 CPU 在一段时间
内使用，这对提高程序的运行速度有很大的作用。这类介于主存和 CPU 之间的高速小容量存储器
称作高速 cache。
比较常见的 cache 包括 icache 和 dcache。icache 的使用比较简单，系统刚上电时，icache
中的内容是无效的，并且 icache 的功能是关闭的，往 CP15 协处理器中的寄存器 1 的 bit[12]写
1 可以启动 icache，写 0 可以停止 icache。icache 关闭时，CPU 每次取指都要读主存，性能非常
低。因为 icache 可随时启动，越早开 icache 越好。
与 icache 相似，系统刚上电时, dcache 中的内容是无效的，并且 dcache 的功能是关闭的，
往 CP15 协处理器中的寄存器1的bit[2]写1可以启动dcache，写0可以停止dcache。因为 dcache
必须在启动 mmu 后才能被启动，而对于裸机而言，没必要开 mmu，所以本教程的程序将不会启动
dcache。
#ifdef CONFIG_SYS_ICACHE_OFF
bic r0, r0, #0x00001000 // 关闭 icache
#else
orr r0, r0, #0x00001000 // 打开 icache
#endif
mcr p15, 0, r0, c1, c0, 0
当没有定义 CONFIG_SYS_ICACHE_OFF 时启动 icache，为 1 时关闭 icache。至于协处理器的相
关指令，需查阅 s3c2410 的芯片手册或者《arm 体系结构与编程》一书。

疑问：相比程序 2.leds_c_sp， LED 闪烁变快了好几倍。由于 ichace 可以提高 CPU 的取指速度以及
可以随时打开，所以程序里应该尽早的打开 icache。？
意思是除了主频影响着速度，cache也有很大的影响了咯，那我延时函数不有问题了，不能精准了！？？？？

//----------------------------------------------------------------------------------------------------
							第七章 初始化时钟
//----------------------------------------------------------------------------------------------------

。。。。我去，前面的程序没有时钟？怎么回事？
。。。。。每个外设块的时钟信号可能被启用或禁用，由软件控制以减少电源消耗。。。。。。。。
对于简单的裸机程序，基本上只需要设置好 MPLL 就可以满足大多数模块的时钟要求了，具体如何设置上述各种各样的时钟，可参考下图：


昨天想给2416 内存降频，开始一直以2440 的思维去看，2440 的HCLK 就是 内存的频率，所以2416 也应该是是这个吧。
可是TMD 2416 居然在框架图以及手册不断的强调DDRCLK 并且煞有其事的拿DDRCLK说事，并且DDRCLK
一直都是所谓的266M......并且图示里面DDRCLK和HCLK是并行的，HCLK无法干预DDRCLK，但是DDRCLK 又找不到设置的地方，真是神奇了。
真是服了三星了，手册把DDRCLK 里面一个图示里面HCLK*2的字眼弄得很小，是图片来的，无法查看，刚才放大图片才看见，郁闷。
也就是说DDRCLK 是等于HCLK*2 的了?!---------------------三星你这个鸟蛋！
没想到都是忽悠的，2416 的内存频率依然是来自HCLK 设置即可。手册page 672 如下：
The AHB and APB clocks are en/disabled by HCLKCON register. All reserved bits have 1 value at initial state.  .......
http://www.cnblogs.com/gooogleman/archive/2011/08/31/2160515.html

为什么调用C函数要设置栈?
栈有三个作用，包括：保存现场；传递参数:汇编代码调用C函数时，需传递参数；保存临时
变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量；

设置栈，其实就是设置SP寄存器，让其指向一块可用的内存。SD启动时，S3C2451的内部
8K的SRAM被映射到0x40000000，而ARM默认的栈是递减的，所以可以让SP指向0x40002000；
为什么是0x40000000？

0x2000  = 8*1024  =8K  又糊涂了

为什么要在C语言中调用汇编函数？
1)  汇编执行的代码效率更高；
2)  某些操作使用汇编编写代码更方便，如对协处理器的操作；

delay:
delay_loop: 
cmp r0, #02
sub r0, r0, #1
bne delay_loop
mov pc, lr
延时部分的代码调用的是start.S中的 delay()函数，参数通过r0传递。默认用r0参数还是怎么的？


怎么初始化个时钟还这么麻烦！
1.  设置分频
2.	设置锁定时间
设置 PLL 后，时钟从 Fin 提升到目标频率时，需要一定的时间，即锁定时间。我们设置为最大值。
3.	设置PLL
设置好分频和锁定时间后，我们就需要设置 PLL 了。MPLL 的启动是通过设置 MPLLCON 寄存器：
4.	设置各种时钟开关

是不是不管什么芯片总有这几个步骤呢？

//----------------------------------------------------------------------------------------------------
							BOOT
//----------------------------------------------------------------------------------------------------

S3C2451 支持两种启动
方式，一是 OneNAND 启动，二是 IROM 启动。Mini2451 并没有 OneNAND，所以它使用的是第二种
启动方式。S3C2451 含有一个 64K 的 IROM 和 8K 的 SRAM。IROM 和 SRAM 所处的存储空间见下图，
可以看出，当采用 IROM 启动时，IROM 位于 0x0 地址处，而 SRAM 位于 0x40000000：

